{"ast":null,"code":"import { PostgrestBuilder } from './types';\n/**\n * Post-filters (transforms)\n */\n\nexport default class PostgrestTransformBuilder extends PostgrestBuilder {\n  /**\n   * Performs vertical filtering with SELECT.\n   *\n   * @param columns  The columns to retrieve, separated by commas.\n   */\n  select() {\n    let columns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '*';\n    // Remove whitespaces except when quoted\n    let quoted = false;\n    const cleanedColumns = columns.split('').map(c => {\n      if (/\\s/.test(c) && !quoted) {\n        return '';\n      }\n\n      if (c === '\"') {\n        quoted = !quoted;\n      }\n\n      return c;\n    }).join('');\n    this.url.searchParams.set('select', cleanedColumns);\n    return this;\n  }\n  /**\n   * Orders the result with the specified `column`.\n   *\n   * @param column  The column to order on.\n   * @param ascending  If `true`, the result will be in ascending order.\n   * @param nullsFirst  If `true`, `null`s appear first.\n   * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n   */\n\n\n  order(column) {\n    let {\n      ascending = true,\n      nullsFirst = false,\n      foreignTable\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const key = typeof foreignTable === 'undefined' ? 'order' : `${foreignTable}.order`;\n    const existingOrder = this.url.searchParams.get(key);\n    this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}.${nullsFirst ? 'nullsfirst' : 'nullslast'}`);\n    return this;\n  }\n  /**\n   * Limits the result with the specified `count`.\n   *\n   * @param count  The maximum no. of rows to limit to.\n   * @param foreignTable  The foreign table to use (for foreign columns).\n   */\n\n\n  limit(count) {\n    let {\n      foreignTable\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const key = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`;\n    this.url.searchParams.set(key, `${count}`);\n    return this;\n  }\n  /**\n   * Limits the result to rows within the specified range, inclusive.\n   *\n   * @param from  The starting index from which to limit the result, inclusive.\n   * @param to  The last index to which to limit the result, inclusive.\n   * @param foreignTable  The foreign table to use (for foreign columns).\n   */\n\n\n  range(from, to) {\n    let {\n      foreignTable\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const keyOffset = typeof foreignTable === 'undefined' ? 'offset' : `${foreignTable}.offset`;\n    const keyLimit = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`;\n    this.url.searchParams.set(keyOffset, `${from}`); // Range is inclusive, so add 1\n\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n    return this;\n  }\n  /**\n   * Sets the AbortSignal for the fetch request.\n   */\n\n\n  abortSignal(signal) {\n    this.signal = signal;\n    return this;\n  }\n  /**\n   * Retrieves only one row from the result. Result must be one row (e.g. using\n   * `limit`), otherwise this will result in an error.\n   */\n\n\n  single() {\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n    return this;\n  }\n  /**\n   * Retrieves at most one row from the result. Result must be at most one row\n   * (e.g. using `eq` on a UNIQUE column), otherwise this will result in an\n   * error.\n   */\n\n\n  maybeSingle() {\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n\n    const _this = new PostgrestTransformBuilder(this);\n\n    _this.then = (onfulfilled, onrejected) => this.then(res => {\n      var _a, _b;\n\n      if ((_b = (_a = res.error) === null || _a === void 0 ? void 0 : _a.details) === null || _b === void 0 ? void 0 : _b.includes('Results contain 0 rows')) {\n        return onfulfilled({\n          error: null,\n          data: null,\n          count: res.count,\n          status: 200,\n          statusText: 'OK',\n          body: null\n        });\n      }\n\n      return onfulfilled(res);\n    }, onrejected);\n\n    return _this;\n  }\n  /**\n   * Set the response type to CSV.\n   */\n\n\n  csv() {\n    this.headers['Accept'] = 'text/csv';\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["PostgrestBuilder","PostgrestTransformBuilder","select","columns","quoted","cleanedColumns","split","map","c","test","join","url","searchParams","set","order","column","ascending","nullsFirst","foreignTable","key","existingOrder","get","limit","count","range","from","to","keyOffset","keyLimit","abortSignal","signal","single","headers","maybeSingle","_this","then","onfulfilled","onrejected","res","error","_a","details","_b","includes","data","status","statusText","body","csv"],"sources":["/home/gabriel/Dropbox/Ufersa/Aulas/PW/2021.2/Unidade 2/aula 8 - pratica/todo/node_modules/@supabase/postgrest-js/src/lib/PostgrestTransformBuilder.ts"],"sourcesContent":["import { PostgrestBuilder, PostgrestMaybeSingleResponse, PostgrestSingleResponse } from './types'\n\n/**\n * Post-filters (transforms)\n */\n\nexport default class PostgrestTransformBuilder<T> extends PostgrestBuilder<T> {\n  /**\n   * Performs vertical filtering with SELECT.\n   *\n   * @param columns  The columns to retrieve, separated by commas.\n   */\n  select(columns = '*'): this {\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = columns\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    return this\n  }\n\n  /**\n   * Orders the result with the specified `column`.\n   *\n   * @param column  The column to order on.\n   * @param ascending  If `true`, the result will be in ascending order.\n   * @param nullsFirst  If `true`, `null`s appear first.\n   * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n   */\n  order(\n    column: keyof T,\n    {\n      ascending = true,\n      nullsFirst = false,\n      foreignTable,\n    }: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: string } = {}\n  ): this {\n    const key = typeof foreignTable === 'undefined' ? 'order' : `${foreignTable}.order`\n    const existingOrder = this.url.searchParams.get(key)\n\n    this.url.searchParams.set(\n      key,\n      `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}.${\n        nullsFirst ? 'nullsfirst' : 'nullslast'\n      }`\n    )\n    return this\n  }\n\n  /**\n   * Limits the result with the specified `count`.\n   *\n   * @param count  The maximum no. of rows to limit to.\n   * @param foreignTable  The foreign table to use (for foreign columns).\n   */\n  limit(count: number, { foreignTable }: { foreignTable?: string } = {}): this {\n    const key = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\n    this.url.searchParams.set(key, `${count}`)\n    return this\n  }\n\n  /**\n   * Limits the result to rows within the specified range, inclusive.\n   *\n   * @param from  The starting index from which to limit the result, inclusive.\n   * @param to  The last index to which to limit the result, inclusive.\n   * @param foreignTable  The foreign table to use (for foreign columns).\n   */\n  range(from: number, to: number, { foreignTable }: { foreignTable?: string } = {}): this {\n    const keyOffset = typeof foreignTable === 'undefined' ? 'offset' : `${foreignTable}.offset`\n    const keyLimit = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\n    this.url.searchParams.set(keyOffset, `${from}`)\n    // Range is inclusive, so add 1\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`)\n    return this\n  }\n\n  /**\n   * Sets the AbortSignal for the fetch request.\n   */\n  abortSignal(signal: AbortSignal): this {\n    this.signal = signal\n    return this\n  }\n\n  /**\n   * Retrieves only one row from the result. Result must be one row (e.g. using\n   * `limit`), otherwise this will result in an error.\n   */\n  single(): PromiseLike<PostgrestSingleResponse<T>> {\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\n    return this as PromiseLike<PostgrestSingleResponse<T>>\n  }\n\n  /**\n   * Retrieves at most one row from the result. Result must be at most one row\n   * (e.g. using `eq` on a UNIQUE column), otherwise this will result in an\n   * error.\n   */\n  maybeSingle(): PromiseLike<PostgrestMaybeSingleResponse<T>> {\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\n    const _this = new PostgrestTransformBuilder(this)\n    _this.then = ((onfulfilled: any, onrejected: any) =>\n      this.then((res: any): any => {\n        if (res.error?.details?.includes('Results contain 0 rows')) {\n          return onfulfilled({\n            error: null,\n            data: null,\n            count: res.count,\n            status: 200,\n            statusText: 'OK',\n            body: null,\n          })\n        }\n\n        return onfulfilled(res)\n      }, onrejected)) as any\n    return _this as PromiseLike<PostgrestMaybeSingleResponse<T>>\n  }\n\n  /**\n   * Set the response type to CSV.\n   */\n  csv(): PromiseLike<PostgrestSingleResponse<string>> {\n    this.headers['Accept'] = 'text/csv'\n    return this as PromiseLike<PostgrestSingleResponse<string>>\n  }\n}\n"]},"metadata":{},"sourceType":"module"}