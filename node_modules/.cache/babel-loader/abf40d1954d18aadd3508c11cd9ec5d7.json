{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { get, post, put, remove } from './lib/fetch';\nimport { COOKIE_OPTIONS } from './lib/constants';\nimport { setCookies, getCookieString } from './lib/cookies';\nimport { expiresAt, resolveFetch } from './lib/helpers';\nexport default class GoTrueApi {\n  constructor(_ref) {\n    let {\n      url = '',\n      headers = {},\n      cookieOptions,\n      fetch\n    } = _ref;\n    this.url = url;\n    this.headers = headers;\n    this.cookieOptions = Object.assign(Object.assign({}, COOKIE_OPTIONS), cookieOptions);\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n\n\n  _createRequestHeaders(jwt) {\n    const headers = Object.assign({}, this.headers);\n    headers['Authorization'] = `Bearer ${jwt}`;\n    return headers;\n  }\n\n  cookieName() {\n    var _a;\n\n    return (_a = this.cookieOptions.name) !== null && _a !== void 0 ? _a : '';\n  }\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n\n\n  getUrlForProvider(provider, options) {\n    const urlParams = [`provider=${encodeURIComponent(provider)}`];\n\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n    }\n\n    return `${this.url}/authorize?${urlParams.join('&')}`;\n  }\n  /**\n   * Creates a new user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n\n\n  signUpWithEmail(email, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/signup${queryString}`, {\n          email,\n          password,\n          data: options.data,\n          gotrue_meta_security: {\n            hcaptcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an existing user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  signInWithEmail(email, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '?grant_type=password';\n\n        if (options.redirectTo) {\n          queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          email,\n          password\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Signs up a new user using their phone number and a password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param data Optional user metadata.\n   */\n\n\n  signUpWithPhone(phone, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/signup`, {\n          phone,\n          password,\n          data: options.data,\n          gotrue_meta_security: {\n            hcaptcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an existing user using their phone number and password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   */\n\n\n  signInWithPhone(phone, password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const queryString = '?grant_type=password';\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          phone,\n          password\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an OpenID Connect user using their id_token.\n   * @param id_token The IDToken of the user.\n   * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n   * @param provider The provider of the user.\n   * @param client_id The clientID of the user.\n   * @param issuer The issuer of the user.\n   */\n\n\n  signInWithOpenIDConnect(_ref2) {\n    let {\n      id_token,\n      nonce,\n      client_id,\n      issuer,\n      provider\n    } = _ref2;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const queryString = '?grant_type=id_token';\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          id_token,\n          nonce,\n          client_id,\n          issuer,\n          provider\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a magic login link to an email address.\n   * @param email The email address of the user.\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  sendMagicLinkEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n        const data = yield post(this.fetch, `${this.url}/otp${queryString}`, {\n          email,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: {\n            hcaptcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n   * @param phone The user's phone number WITH international prefix\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   */\n\n\n  sendMobileOTP(phone) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/otp`, {\n          phone,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: {\n            hcaptcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n\n\n  signOut(jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield post(this.fetch, `${this.url}/logout`, {}, {\n          headers: this._createRequestHeaders(jwt),\n          noResolveJson: true\n        });\n        return {\n          error: null\n        };\n      } catch (e) {\n        return {\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * @deprecated Use `verifyOTP` instead!\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  verifyMobileOTP(phone, token) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/verify`, {\n          phone,\n          token,\n          type: 'sms',\n          redirect_to: options.redirectTo\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Send User supplied Email / Mobile OTP to be verified\n   * @param email The user's email address\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param type verification type that the otp is generated for\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  verifyOTP(_ref3) {\n    let {\n      email,\n      phone,\n      token,\n      type = 'sms'\n    } = _ref3;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/verify`, {\n          email,\n          phone,\n          token,\n          type,\n          redirect_to: options.redirectTo\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata\n   */\n\n\n  inviteUserByEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/invite${queryString}`, {\n          email,\n          data: options.data\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a reset request to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  resetPasswordForEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/recover${queryString}`, {\n          email,\n          gotrue_meta_security: {\n            hcaptcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n\n\n  refreshAccessToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/token?grant_type=refresh_token`, {\n          refresh_token: refreshToken\n        }, {\n          headers: this.headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Set/delete the auth cookie based on the AuthChangeEvent.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   * @param req The request object.\n   * @param res The response object.\n   */\n\n\n  setAuthCookie(req, res) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST');\n      res.status(405).end('Method Not Allowed');\n    }\n\n    const {\n      event,\n      session\n    } = req.body;\n    if (!event) throw new Error('Auth event missing!');\n\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!');\n      setCookies(req, res, [{\n        key: 'access-token',\n        value: session.access_token\n      }, {\n        key: 'refresh-token',\n        value: session.refresh_token\n      }].map(token => {\n        var _a;\n\n        return {\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite\n        };\n      }));\n    }\n\n    if (event === 'SIGNED_OUT') {\n      setCookies(req, res, ['access-token', 'refresh-token'].map(key => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1\n      })));\n    }\n\n    res.status(200).json({});\n  }\n  /**\n   * Deletes the Auth Cookies and redirects to the\n   * @param req The request object.\n   * @param res The response object.\n   * @param options Optionally specify a `redirectTo` URL in the options.\n   */\n\n\n  deleteAuthCookie(req, res, _ref4) {\n    let {\n      redirectTo = '/'\n    } = _ref4;\n    setCookies(req, res, ['access-token', 'refresh-token'].map(key => ({\n      name: `${this.cookieName()}-${key}`,\n      value: '',\n      maxAge: -1\n    })));\n    return res.redirect(307, redirectTo);\n  }\n  /**\n   * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n   * @param req The request object.\n   * @param res The response object.\n   * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n   */\n\n\n  getAuthCookieString(req, res) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST');\n      res.status(405).end('Method Not Allowed');\n    }\n\n    const {\n      event,\n      session\n    } = req.body;\n    if (!event) throw new Error('Auth event missing!');\n\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!');\n      return getCookieString(req, res, [{\n        key: 'access-token',\n        value: session.access_token\n      }, {\n        key: 'refresh-token',\n        value: session.refresh_token\n      }].map(token => {\n        var _a;\n\n        return {\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite\n        };\n      }));\n    }\n\n    if (event === 'SIGNED_OUT') {\n      return getCookieString(req, res, ['access-token', 'refresh-token'].map(key => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1\n      })));\n    }\n\n    return res.getHeader('Set-Cookie');\n  }\n  /**\n   * Generates links to be sent via email or other.\n   * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   * @param email The user's email.\n   * @param password User password. For signup only.\n   * @param data Optional user metadata. For signup only.\n   * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   */\n\n\n  generateLink(type, email) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/admin/generate_link`, {\n          type,\n          email,\n          password: options.password,\n          data: options.data,\n          redirect_to: options.redirectTo\n        }, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  } // User Admin API\n\n  /**\n   * Creates a new user.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param attributes The data you want to create the user with.\n   */\n\n\n  createUser(attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/admin/users`, attributes, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n\n\n  listUsers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/admin/users`, {\n          headers: this.headers\n        });\n        return {\n          data: data.users,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n\n\n  getUserById(uid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/admin/users/${uid}`, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get user by reading the cookie from the request.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n\n\n  getUserByCookie(req, res) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!req.cookies) {\n          throw new Error('Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!');\n        }\n\n        const access_token = req.cookies[`${this.cookieName()}-access-token`];\n        const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`];\n\n        if (!access_token) {\n          throw new Error('No cookie found!');\n        }\n\n        const {\n          user,\n          error: getUserError\n        } = yield this.getUser(access_token);\n\n        if (getUserError) {\n          if (!refresh_token) throw new Error('No refresh_token cookie found!');\n          if (!res) throw new Error('You need to pass the res object to automatically refresh the session!');\n          const {\n            data,\n            error\n          } = yield this.refreshAccessToken(refresh_token);\n\n          if (error) {\n            throw error;\n          } else if (data) {\n            setCookies(req, res, [{\n              key: 'access-token',\n              value: data.access_token\n            }, {\n              key: 'refresh-token',\n              value: data.refresh_token\n            }].map(token => {\n              var _a;\n\n              return {\n                name: `${this.cookieName()}-${token.key}`,\n                value: token.value,\n                domain: this.cookieOptions.domain,\n                maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                path: this.cookieOptions.path,\n                sameSite: this.cookieOptions.sameSite\n              };\n            }));\n            return {\n              token: data.access_token,\n              user: data.user,\n              data: data.user,\n              error: null\n            };\n          }\n        }\n\n        return {\n          token: access_token,\n          user: user,\n          data: user,\n          error: null\n        };\n      } catch (e) {\n        return {\n          token: null,\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n\n\n  updateUserById(uid, attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this; //\n\n        const data = yield put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param uid The user uid you want to remove.\n   */\n\n\n  deleteUser(uid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield remove(this.fetch, `${this.url}/admin/users/${uid}`, {}, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Gets the current user details.\n   *\n   * This method is called by the GoTrueClient `update` where\n   * the jwt is set to this.currentSession.access_token\n   * and therefore, acts like getting the currently authenticated used\n   *\n   * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n   */\n\n\n  getUser(jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/user`, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates the user data.\n   * @param jwt A valid, logged-in JWT.\n   * @param attributes The data you want to update.\n   */\n\n\n  updateUser(jwt, attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield put(this.fetch, `${this.url}/user`, attributes, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["get","post","put","remove","COOKIE_OPTIONS","setCookies","getCookieString","expiresAt","resolveFetch","GoTrueApi","constructor","url","headers","cookieOptions","fetch","Object","_createRequestHeaders","jwt","cookieName","name","_a","getUrlForProvider","provider","options","urlParams","encodeURIComponent","redirectTo","push","scopes","join","signUpWithEmail","email","password","queryString","data","gotrue_meta_security","hcaptcha_token","captchaToken","session","expires_in","expires_at","error","e","signInWithEmail","signUpWithPhone","phone","signInWithPhone","signInWithOpenIDConnect","id_token","nonce","client_id","issuer","sendMagicLinkEmail","shouldCreateUser","create_user","sendMobileOTP","signOut","noResolveJson","verifyMobileOTP","token","type","redirect_to","verifyOTP","inviteUserByEmail","resetPasswordForEmail","refreshAccessToken","refreshToken","refresh_token","setAuthCookie","req","res","method","setHeader","status","end","event","body","Error","key","value","access_token","map","domain","maxAge","lifetime","path","sameSite","json","deleteAuthCookie","redirect","getAuthCookieString","getHeader","generateLink","createUser","attributes","user","listUsers","users","getUserById","uid","getUserByCookie","cookies","getUserError","getUser","updateUserById","deleteUser","updateUser"],"sources":["/home/gabriel/Dropbox/Ufersa/Aulas/PW/2021.2/Unidade 2/aula 8 - pratica/todo/node_modules/@supabase/gotrue-js/src/GoTrueApi.ts"],"sourcesContent":["import { Fetch, get, post, put, remove } from './lib/fetch'\nimport {\n  Session,\n  Provider,\n  AdminUserAttributes,\n  UserAttributes,\n  CookieOptions,\n  User,\n  OpenIDConnectCredentials,\n  VerifyOTPParams,\n} from './lib/types'\nimport { COOKIE_OPTIONS } from './lib/constants'\nimport { setCookies, getCookieString } from './lib/cookies'\nimport { expiresAt, resolveFetch } from './lib/helpers'\n\nimport type { ApiError } from './lib/types'\nexport default class GoTrueApi {\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected cookieOptions: CookieOptions\n  protected fetch: Fetch\n\n  constructor({\n    url = '',\n    headers = {},\n    cookieOptions,\n    fetch,\n  }: {\n    url: string\n    headers?: {\n      [key: string]: string\n    }\n    cookieOptions?: CookieOptions\n    fetch?: Fetch\n  }) {\n    this.url = url\n    this.headers = headers\n    this.cookieOptions = { ...COOKIE_OPTIONS, ...cookieOptions }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n  private _createRequestHeaders(jwt: string) {\n    const headers = { ...this.headers }\n    headers['Authorization'] = `Bearer ${jwt}`\n    return headers\n  }\n\n  private cookieName() {\n    return this.cookieOptions.name ?? ''\n  }\n\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  getUrlForProvider(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n    }\n  ) {\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\n    if (options?.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\n    }\n    if (options?.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\n    }\n    return `${this.url}/authorize?${urlParams.join('&')}`\n  }\n\n  /**\n   * Creates a new user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  async signUpWithEmail(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n      data?: object\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/signup${queryString}`,\n        {\n          email,\n          password,\n          data: options.data,\n          gotrue_meta_security: { hcaptcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an existing user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async signInWithEmail(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = '?grant_type=password'\n      if (options.redirectTo) {\n        queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { email, password },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Signs up a new user using their phone number and a password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param data Optional user metadata.\n   */\n  async signUpWithPhone(\n    phone: string,\n    password: string,\n    options: {\n      data?: object\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/signup`,\n        {\n          phone,\n          password,\n          data: options.data,\n          gotrue_meta_security: { hcaptcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an existing user using their phone number and password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   */\n  async signInWithPhone(\n    phone: string,\n    password: string\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const queryString = '?grant_type=password'\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { phone, password },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an OpenID Connect user using their id_token.\n   * @param id_token The IDToken of the user.\n   * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n   * @param provider The provider of the user.\n   * @param client_id The clientID of the user.\n   * @param issuer The issuer of the user.\n   */\n  async signInWithOpenIDConnect({\n    id_token,\n    nonce,\n    client_id,\n    issuer,\n    provider,\n  }: OpenIDConnectCredentials): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const queryString = '?grant_type=id_token'\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { id_token, nonce, client_id, issuer, provider },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a magic login link to an email address.\n   * @param email The email address of the user.\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async sendMagicLinkEmail(\n    email: string,\n    options: {\n      shouldCreateUser?: boolean\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n\n      const shouldCreateUser = options.shouldCreateUser ?? true\n      const data = await post(\n        this.fetch,\n        `${this.url}/otp${queryString}`,\n        {\n          email,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: { hcaptcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n   * @param phone The user's phone number WITH international prefix\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   */\n  async sendMobileOTP(\n    phone: string,\n    options: {\n      shouldCreateUser?: boolean\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const shouldCreateUser = options.shouldCreateUser ?? true\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/otp`,\n        {\n          phone,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: { hcaptcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n  async signOut(jwt: string): Promise<{ error: ApiError | null }> {\n    try {\n      await post(\n        this.fetch,\n        `${this.url}/logout`,\n        {},\n        { headers: this._createRequestHeaders(jwt), noResolveJson: true }\n      )\n      return { error: null }\n    } catch (e) {\n      return { error: e as ApiError }\n    }\n  }\n\n  /**\n   * @deprecated Use `verifyOTP` instead!\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyMobileOTP(\n    phone: string,\n    token: string,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/verify`,\n        { phone, token, type: 'sms', redirect_to: options.redirectTo },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Send User supplied Email / Mobile OTP to be verified\n   * @param email The user's email address\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param type verification type that the otp is generated for\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyOTP(\n    { email, phone, token, type = 'sms' }: VerifyOTPParams,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/verify`,\n        { email, phone, token, type, redirect_to: options.redirectTo },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata\n   */\n  async inviteUserByEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      data?: object\n    } = {}\n  ): Promise<{ data: User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/invite${queryString}`,\n        { email, data: options.data },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a reset request to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async resetPasswordForEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/recover${queryString}`,\n        { email, gotrue_meta_security: { hcaptcha_token: options.captchaToken } },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  async refreshAccessToken(\n    refreshToken: string\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const data: any = await post(\n        this.fetch,\n        `${this.url}/token?grant_type=refresh_token`,\n        { refresh_token: refreshToken },\n        { headers: this.headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Set/delete the auth cookie based on the AuthChangeEvent.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   * @param req The request object.\n   * @param res The response object.\n   */\n  setAuthCookie(req: any, res: any) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST')\n      res.status(405).end('Method Not Allowed')\n    }\n    const { event, session } = req.body\n\n    if (!event) throw new Error('Auth event missing!')\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!')\n      setCookies(\n        req,\n        res,\n        [\n          { key: 'access-token', value: session.access_token },\n          { key: 'refresh-token', value: session.refresh_token },\n        ].map((token) => ({\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: this.cookieOptions.lifetime ?? 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite,\n        }))\n      )\n    }\n    if (event === 'SIGNED_OUT') {\n      setCookies(\n        req,\n        res,\n        ['access-token', 'refresh-token'].map((key) => ({\n          name: `${this.cookieName()}-${key}`,\n          value: '',\n          maxAge: -1,\n        }))\n      )\n    }\n    res.status(200).json({})\n  }\n\n  /**\n   * Deletes the Auth Cookies and redirects to the\n   * @param req The request object.\n   * @param res The response object.\n   * @param options Optionally specify a `redirectTo` URL in the options.\n   */\n  deleteAuthCookie(req: any, res: any, { redirectTo = '/' }: { redirectTo?: string }) {\n    setCookies(\n      req,\n      res,\n      ['access-token', 'refresh-token'].map((key) => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1,\n      }))\n    )\n    return res.redirect(307, redirectTo)\n  }\n\n  /**\n   * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n   * @param req The request object.\n   * @param res The response object.\n   * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n   */\n  getAuthCookieString(req: any, res: any): string[] {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST')\n      res.status(405).end('Method Not Allowed')\n    }\n    const { event, session } = req.body\n\n    if (!event) throw new Error('Auth event missing!')\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!')\n      return getCookieString(\n        req,\n        res,\n        [\n          { key: 'access-token', value: session.access_token },\n          { key: 'refresh-token', value: session.refresh_token },\n        ].map((token) => ({\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: this.cookieOptions.lifetime ?? 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite,\n        }))\n      )\n    }\n    if (event === 'SIGNED_OUT') {\n      return getCookieString(\n        req,\n        res,\n        ['access-token', 'refresh-token'].map((key) => ({\n          name: `${this.cookieName()}-${key}`,\n          value: '',\n          maxAge: -1,\n        }))\n      )\n    }\n    return res.getHeader('Set-Cookie')\n  }\n\n  /**\n   * Generates links to be sent via email or other.\n   * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   * @param email The user's email.\n   * @param password User password. For signup only.\n   * @param data Optional user metadata. For signup only.\n   * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   */\n  async generateLink(\n    type: 'signup' | 'magiclink' | 'recovery' | 'invite',\n    email: string,\n    options: {\n      password?: string\n      data?: object\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const data: any = await post(\n        this.fetch,\n        `${this.url}/admin/generate_link`,\n        {\n          type,\n          email,\n          password: options.password,\n          data: options.data,\n          redirect_to: options.redirectTo,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  // User Admin API\n\n  /**\n   * Creates a new user.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param attributes The data you want to create the user with.\n   */\n  async createUser(\n    attributes: AdminUserAttributes\n  ): Promise<\n    { user: null; data: null; error: ApiError } | { user: User; data: User; error: null }\n  > {\n    try {\n      const data: any = await post(this.fetch, `${this.url}/admin/users`, attributes, {\n        headers: this.headers,\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async listUsers(): Promise<{ data: null; error: ApiError } | { data: User[]; error: null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/admin/users`, {\n        headers: this.headers,\n      })\n      return { data: data.users, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async getUserById(\n    uid: string\n  ): Promise<{ data: null; error: ApiError } | { data: User; error: null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/admin/users/${uid}`, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get user by reading the cookie from the request.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n  async getUserByCookie(\n    req: any,\n    res?: any\n  ): Promise<{\n    token: string | null\n    user: User | null\n    data: User | null\n    error: ApiError | null\n  }> {\n    try {\n      if (!req.cookies) {\n        throw new Error(\n          'Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!'\n        )\n      }\n\n      const access_token = req.cookies[`${this.cookieName()}-access-token`]\n      const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`]\n\n      if (!access_token) {\n        throw new Error('No cookie found!')\n      }\n\n      const { user, error: getUserError } = await this.getUser(access_token)\n      if (getUserError) {\n        if (!refresh_token) throw new Error('No refresh_token cookie found!')\n        if (!res)\n          throw new Error('You need to pass the res object to automatically refresh the session!')\n        const { data, error } = await this.refreshAccessToken(refresh_token)\n        if (error) {\n          throw error\n        } else if (data) {\n          setCookies(\n            req,\n            res,\n            [\n              { key: 'access-token', value: data.access_token },\n              { key: 'refresh-token', value: data.refresh_token! },\n            ].map((token) => ({\n              name: `${this.cookieName()}-${token.key}`,\n              value: token.value,\n              domain: this.cookieOptions.domain,\n              maxAge: this.cookieOptions.lifetime ?? 0,\n              path: this.cookieOptions.path,\n              sameSite: this.cookieOptions.sameSite,\n            }))\n          )\n          return { token: data.access_token, user: data.user, data: data.user, error: null }\n        }\n      }\n      return { token: access_token, user: user, data: user, error: null }\n    } catch (e) {\n      return { token: null, user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async updateUserById(\n    uid: string,\n    attributes: AdminUserAttributes\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      this //\n      const data: any = await put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n        headers: this.headers,\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param uid The user uid you want to remove.\n   */\n  async deleteUser(\n    uid: string\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await remove(\n        this.fetch,\n        `${this.url}/admin/users/${uid}`,\n        {},\n        {\n          headers: this.headers,\n        }\n      )\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Gets the current user details.\n   *\n   * This method is called by the GoTrueClient `update` where\n   * the jwt is set to this.currentSession.access_token\n   * and therefore, acts like getting the currently authenticated used\n   *\n   * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n   */\n  async getUser(\n    jwt: string\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/user`, {\n        headers: this._createRequestHeaders(jwt),\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates the user data.\n   * @param jwt A valid, logged-in JWT.\n   * @param attributes The data you want to update.\n   */\n  async updateUser(\n    jwt: string,\n    attributes: UserAttributes\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await put(this.fetch, `${this.url}/user`, attributes, {\n        headers: this._createRequestHeaders(jwt),\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}