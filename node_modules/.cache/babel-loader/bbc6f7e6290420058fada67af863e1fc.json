{"ast":null,"code":"import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nexport default class RealtimeSubscription {\n  constructor(topic) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let socket = arguments.length > 2 ? arguments[2] : undefined;\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = [];\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this.rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError(reason => {\n      if (this.isLeaving() || this.isClosed()) {\n        return;\n      }\n\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', () => {\n      if (!this.isJoining()) {\n        return;\n      }\n\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload);\n    });\n  }\n\n  rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n\n    if (this.socket.isConnected()) {\n      this.rejoin();\n    }\n  }\n\n  subscribe() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n    } else {\n      this.joinedOnce = true;\n      this.rejoin(timeout);\n      return this.joinPush;\n    }\n  }\n\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, callback);\n  }\n\n  onError(callback) {\n    this.on(CHANNEL_EVENTS.error, reason => callback(reason));\n  }\n\n  on(event, callback) {\n    this.bindings.push({\n      event,\n      callback\n    });\n  }\n\n  off(event) {\n    this.bindings = this.bindings.filter(bind => bind.event !== event);\n  }\n\n  canPush() {\n    return this.socket.isConnected() && this.isJoined();\n  }\n\n  push(event, payload) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n    }\n\n    let pushEvent = new Push(this, event, payload, timeout);\n\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n\n    return pushEvent;\n  }\n\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  /**\n   * Leaves the channel\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n\n\n  unsubscribe() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n    this.state = CHANNEL_STATES.leaving;\n\n    let onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`);\n      this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef());\n    }; // Destroy joinPush to avoid connection timeouts during unscription phase\n\n\n    this.joinPush.destroy();\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n    leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose());\n    leavePush.send();\n\n    if (!this.canPush()) {\n      leavePush.trigger('ok', {});\n    }\n\n    return leavePush;\n  }\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   */\n\n\n  onMessage(event, payload, ref) {\n    return payload;\n  }\n\n  isMember(topic) {\n    return this.topic === topic;\n  }\n\n  joinRef() {\n    return this.joinPush.ref;\n  }\n\n  rejoin() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n    if (this.isLeaving()) {\n      return;\n    }\n\n    this.socket.leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n\n  trigger(event, payload, ref) {\n    let {\n      close,\n      error,\n      leave,\n      join\n    } = CHANNEL_EVENTS;\n    let events = [close, error, leave, join];\n\n    if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {\n      return;\n    }\n\n    let handledPayload = this.onMessage(event, payload, ref);\n\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n    }\n\n    this.bindings.filter(bind => {\n      // Bind all events if the user specifies a wildcard.\n      if (bind.event === '*') {\n        return event === (payload === null || payload === void 0 ? void 0 : payload.type);\n      } else {\n        return bind.event === event;\n      }\n    }).map(bind => bind.callback(handledPayload, ref));\n  }\n\n  replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored;\n  }\n\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,cAAT,EAAyBC,cAAzB,QAA+C,iBAA/C;AACA,OAAOC,IAAP,MAAiB,YAAjB;AAEA,OAAOC,KAAP,MAAkB,aAAlB;AAEA,eAAc,MAAOC,oBAAP,CAA2B;EASvCC,YACSC,KADT,EAG+B;IAAA,IADtBC,MACsB,uEADe,EACf;IAAA,IAAtBC,MAAsB;IAFtB;IACA;IACA;IAXT,gBAAkB,EAAlB;IAEA,aAAQP,cAAc,CAACQ,MAAvB;IACA,kBAAa,KAAb;IAGA,kBAAqB,EAArB;IAOE,KAAKC,OAAL,GAAe,KAAKF,MAAL,CAAYE,OAA3B;IACA,KAAKC,QAAL,GAAgB,IAAIT,IAAJ,CACd,IADc,EAEdF,cAAc,CAACY,IAFD,EAGd,KAAKL,MAHS,EAId,KAAKG,OAJS,CAAhB;IAMA,KAAKG,WAAL,GAAmB,IAAIV,KAAJ,CACjB,MAAM,KAAKW,oBAAL,EADW,EAEjB,KAAKN,MAAL,CAAYO,gBAFK,CAAnB;IAIA,KAAKJ,QAAL,CAAcK,OAAd,CAAsB,IAAtB,EAA4B,MAAK;MAC/B,KAAKC,KAAL,GAAahB,cAAc,CAACiB,MAA5B;MACA,KAAKL,WAAL,CAAiBM,KAAjB;MACA,KAAKC,UAAL,CAAgBC,OAAhB,CAAyBC,SAAD,IAAqBA,SAAS,CAACC,IAAV,EAA7C;MACA,KAAKH,UAAL,GAAkB,EAAlB;IACD,CALD;IAMA,KAAKI,OAAL,CAAa,MAAK;MAChB,KAAKX,WAAL,CAAiBM,KAAjB;MACA,KAAKX,MAAL,CAAYiB,GAAZ,CAAgB,SAAhB,EAA2B,SAAS,KAAKnB,KAAK,IAAI,KAAKoB,OAAL,EAAc,EAAhE;MACA,KAAKT,KAAL,GAAahB,cAAc,CAACQ,MAA5B;MACA,KAAKD,MAAL,CAAYmB,MAAZ,CAAmB,IAAnB;IACD,CALD;IAMA,KAAKC,OAAL,CAAcC,MAAD,IAAmB;MAC9B,IAAI,KAAKC,SAAL,MAAoB,KAAKC,QAAL,EAAxB,EAAyC;QACvC;MACD;;MACD,KAAKvB,MAAL,CAAYiB,GAAZ,CAAgB,SAAhB,EAA2B,SAAS,KAAKnB,KAAK,EAA9C,EAAkDuB,MAAlD;MACA,KAAKZ,KAAL,GAAahB,cAAc,CAAC+B,OAA5B;MACA,KAAKnB,WAAL,CAAiBoB,eAAjB;IACD,CAPD;IAQA,KAAKtB,QAAL,CAAcK,OAAd,CAAsB,SAAtB,EAAiC,MAAK;MACpC,IAAI,CAAC,KAAKkB,SAAL,EAAL,EAAuB;QACrB;MACD;;MACD,KAAK1B,MAAL,CAAYiB,GAAZ,CAAgB,SAAhB,EAA2B,WAAW,KAAKnB,KAAK,EAAhD,EAAoD,KAAKK,QAAL,CAAcD,OAAlE;MACA,KAAKO,KAAL,GAAahB,cAAc,CAAC+B,OAA5B;MACA,KAAKnB,WAAL,CAAiBoB,eAAjB;IACD,CAPD;IAQA,KAAKE,EAAL,CAAQnC,cAAc,CAACoC,KAAvB,EAA8B,CAACC,OAAD,EAAeC,GAAf,KAA8B;MAC1D,KAAKC,OAAL,CAAa,KAAKC,cAAL,CAAoBF,GAApB,CAAb,EAAuCD,OAAvC;IACD,CAFD;EAGD;;EAEDvB,oBAAoB;IAClB,KAAKD,WAAL,CAAiBoB,eAAjB;;IACA,IAAI,KAAKzB,MAAL,CAAYiC,WAAZ,EAAJ,EAA+B;MAC7B,KAAKC,MAAL;IACD;EACF;;EAEDC,SAAS,GAAuB;IAAA,IAAtBjC,OAAsB,uEAAZ,KAAKA,OAAO;;IAC9B,IAAI,KAAKkC,UAAT,EAAqB;MACnB,MAAM,sGAAN;IACD,CAFD,MAEO;MACL,KAAKA,UAAL,GAAkB,IAAlB;MACA,KAAKF,MAAL,CAAYhC,OAAZ;MACA,OAAO,KAAKC,QAAZ;IACD;EACF;;EAEDa,OAAO,CAACqB,QAAD,EAAmB;IACxB,KAAKV,EAAL,CAAQnC,cAAc,CAAC8C,KAAvB,EAA8BD,QAA9B;EACD;;EAEDjB,OAAO,CAACiB,QAAD,EAAmB;IACxB,KAAKV,EAAL,CAAQnC,cAAc,CAAC+C,KAAvB,EAA+BlB,MAAD,IAAoBgB,QAAQ,CAAChB,MAAD,CAA1D;EACD;;EAEDM,EAAE,CAACa,KAAD,EAAgBH,QAAhB,EAAkC;IAClC,KAAKI,QAAL,CAAcC,IAAd,CAAmB;MAAEF,KAAF;MAASH;IAAT,CAAnB;EACD;;EAEDM,GAAG,CAACH,KAAD,EAAc;IACf,KAAKC,QAAL,GAAgB,KAAKA,QAAL,CAAcG,MAAd,CAAsBC,IAAD,IAAUA,IAAI,CAACL,KAAL,KAAeA,KAA9C,CAAhB;EACD;;EAEDM,OAAO;IACL,OAAO,KAAK9C,MAAL,CAAYiC,WAAZ,MAA6B,KAAKc,QAAL,EAApC;EACD;;EAEDL,IAAI,CAACF,KAAD,EAAwBX,OAAxB,EAA4D;IAAA,IAAtB3B,OAAsB,uEAAZ,KAAKA,OAAO;;IAC9D,IAAI,CAAC,KAAKkC,UAAV,EAAsB;MACpB,MAAM,kBAAkBI,KAAK,SAAS,KAAK1C,KAAK,iEAAhD;IACD;;IACD,IAAIgB,SAAS,GAAG,IAAIpB,IAAJ,CAAS,IAAT,EAAe8C,KAAf,EAAsBX,OAAtB,EAA+B3B,OAA/B,CAAhB;;IACA,IAAI,KAAK4C,OAAL,EAAJ,EAAoB;MAClBhC,SAAS,CAACC,IAAV;IACD,CAFD,MAEO;MACLD,SAAS,CAACkC,YAAV;MACA,KAAKpC,UAAL,CAAgB8B,IAAhB,CAAqB5B,SAArB;IACD;;IAED,OAAOA,SAAP;EACD;;EAEDmC,iBAAiB,CAACpB,OAAD,EAAoC;IACnD,KAAK1B,QAAL,CAAc+C,aAAd,CAA4BrB,OAA5B;EACD;EAED;;;;;;;;;;;EASAsB,WAAW,GAAuB;IAAA,IAAtBjD,OAAsB,uEAAZ,KAAKA,OAAO;IAChC,KAAKO,KAAL,GAAahB,cAAc,CAAC2D,OAA5B;;IACA,IAAIpC,OAAO,GAAG,MAAK;MACjB,KAAKhB,MAAL,CAAYiB,GAAZ,CAAgB,SAAhB,EAA2B,SAAS,KAAKnB,KAAK,EAA9C;MACA,KAAKiC,OAAL,CAAavC,cAAc,CAAC8C,KAA5B,EAAmC,OAAnC,EAA4C,KAAKpB,OAAL,EAA5C;IACD,CAHD,CAFgC,CAMhC;;;IACA,KAAKf,QAAL,CAAckD,OAAd;IAEA,IAAIC,SAAS,GAAG,IAAI5D,IAAJ,CAAS,IAAT,EAAeF,cAAc,CAAC+D,KAA9B,EAAqC,EAArC,EAAyCrD,OAAzC,CAAhB;IACAoD,SAAS,CAAC9C,OAAV,CAAkB,IAAlB,EAAwB,MAAMQ,OAAO,EAArC,EAAyCR,OAAzC,CAAiD,SAAjD,EAA4D,MAAMQ,OAAO,EAAzE;IACAsC,SAAS,CAACvC,IAAV;;IACA,IAAI,CAAC,KAAK+B,OAAL,EAAL,EAAqB;MACnBQ,SAAS,CAACvB,OAAV,CAAkB,IAAlB,EAAwB,EAAxB;IACD;;IAED,OAAOuB,SAAP;EACD;EAED;;;;;;;;EAMAE,SAAS,CAAChB,KAAD,EAAgBX,OAAhB,EAA8BC,GAA9B,EAA0C;IACjD,OAAOD,OAAP;EACD;;EAED4B,QAAQ,CAAC3D,KAAD,EAAc;IACpB,OAAO,KAAKA,KAAL,KAAeA,KAAtB;EACD;;EAEDoB,OAAO;IACL,OAAO,KAAKf,QAAL,CAAc2B,GAArB;EACD;;EAEDI,MAAM,GAAuB;IAAA,IAAtBhC,OAAsB,uEAAZ,KAAKA,OAAO;;IAC3B,IAAI,KAAKoB,SAAL,EAAJ,EAAsB;MACpB;IACD;;IACD,KAAKtB,MAAL,CAAY0D,cAAZ,CAA2B,KAAK5D,KAAhC;IACA,KAAKW,KAAL,GAAahB,cAAc,CAACkE,OAA5B;IACA,KAAKxD,QAAL,CAAcyD,MAAd,CAAqB1D,OAArB;EACD;;EAED6B,OAAO,CAACS,KAAD,EAAgBX,OAAhB,EAA+BC,GAA/B,EAA2C;IAChD,IAAI;MAAEQ,KAAF;MAASC,KAAT;MAAgBgB,KAAhB;MAAuBnD;IAAvB,IAAgCZ,cAApC;IACA,IAAIqE,MAAM,GAAa,CAACvB,KAAD,EAAQC,KAAR,EAAegB,KAAf,EAAsBnD,IAAtB,CAAvB;;IACA,IAAI0B,GAAG,IAAI+B,MAAM,CAACC,OAAP,CAAetB,KAAf,KAAyB,CAAhC,IAAqCV,GAAG,KAAK,KAAKZ,OAAL,EAAjD,EAAiE;MAC/D;IACD;;IACD,IAAI6C,cAAc,GAAG,KAAKP,SAAL,CAAehB,KAAf,EAAsBX,OAAtB,EAA+BC,GAA/B,CAArB;;IACA,IAAID,OAAO,IAAI,CAACkC,cAAhB,EAAgC;MAC9B,MAAM,6EAAN;IACD;;IAED,KAAKtB,QAAL,CACGG,MADH,CACWC,IAAD,IAAS;MACf;MACA,IAAIA,IAAI,CAACL,KAAL,KAAe,GAAnB,EAAwB;QACtB,OAAOA,KAAK,MAAKX,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEmC,IAAd,CAAZ;MACD,CAFD,MAEO;QACL,OAAOnB,IAAI,CAACL,KAAL,KAAeA,KAAtB;MACD;IACF,CARH,EASGyB,GATH,CASQpB,IAAD,IAAUA,IAAI,CAACR,QAAL,CAAc0B,cAAd,EAA8BjC,GAA9B,CATjB;EAUD;;EAEDE,cAAc,CAACF,GAAD,EAAY;IACxB,OAAO,cAAcA,GAAG,EAAxB;EACD;;EAEDP,QAAQ;IACN,OAAO,KAAKd,KAAL,KAAehB,cAAc,CAACQ,MAArC;EACD;;EACDiE,SAAS;IACP,OAAO,KAAKzD,KAAL,KAAehB,cAAc,CAAC+B,OAArC;EACD;;EACDuB,QAAQ;IACN,OAAO,KAAKtC,KAAL,KAAehB,cAAc,CAACiB,MAArC;EACD;;EACDgB,SAAS;IACP,OAAO,KAAKjB,KAAL,KAAehB,cAAc,CAACkE,OAArC;EACD;;EACDrC,SAAS;IACP,OAAO,KAAKb,KAAL,KAAehB,cAAc,CAAC2D,OAArC;EACD;;AAlNsC","names":["CHANNEL_EVENTS","CHANNEL_STATES","Push","Timer","RealtimeSubscription","constructor","topic","params","socket","closed","timeout","joinPush","join","rejoinTimer","rejoinUntilConnected","reconnectAfterMs","receive","state","joined","reset","pushBuffer","forEach","pushEvent","send","onClose","log","joinRef","remove","onError","reason","isLeaving","isClosed","errored","scheduleTimeout","isJoining","on","reply","payload","ref","trigger","replyEventName","isConnected","rejoin","subscribe","joinedOnce","callback","close","error","event","bindings","push","off","filter","bind","canPush","isJoined","startTimeout","updateJoinPayload","updatePayload","unsubscribe","leaving","destroy","leavePush","leave","onMessage","isMember","leaveOpenTopic","joining","resend","events","indexOf","handledPayload","type","map","isErrored"],"sources":["/home/gabriel/Dropbox/Ufersa/Aulas/PW/2021.2/Unidade 2/aula 8 - pratica/todo/node_modules/@supabase/realtime-js/src/RealtimeSubscription.ts"],"sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\nimport Push from './lib/push'\nimport RealtimeClient from './RealtimeClient'\nimport Timer from './lib/timer'\n\nexport default class RealtimeSubscription {\n  bindings: any[] = []\n  timeout: number\n  state = CHANNEL_STATES.closed\n  joinedOnce = false\n  joinPush: Push\n  rejoinTimer: Timer\n  pushBuffer: Push[] = []\n\n  constructor(\n    public topic: string,\n    public params: { [key: string]: unknown } = {},\n    public socket: RealtimeClient\n  ) {\n    this.timeout = this.socket.timeout\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout\n    )\n    this.rejoinTimer = new Timer(\n      () => this.rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this.onClose(() => {\n      this.rejoinTimer.reset()\n      this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket.remove(this)\n    })\n    this.onError((reason: string) => {\n      if (this.isLeaving() || this.isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive('timeout', () => {\n      if (!this.isJoining()) {\n        return\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.on(CHANNEL_EVENTS.reply, (payload: any, ref: string) => {\n      this.trigger(this.replyEventName(ref), payload)\n    })\n  }\n\n  rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout()\n    if (this.socket.isConnected()) {\n      this.rejoin()\n    }\n  }\n\n  subscribe(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\n    } else {\n      this.joinedOnce = true\n      this.rejoin(timeout)\n      return this.joinPush\n    }\n  }\n\n  onClose(callback: Function) {\n    this.on(CHANNEL_EVENTS.close, callback)\n  }\n\n  onError(callback: Function) {\n    this.on(CHANNEL_EVENTS.error, (reason: string) => callback(reason))\n  }\n\n  on(event: string, callback: Function) {\n    this.bindings.push({ event, callback })\n  }\n\n  off(event: string) {\n    this.bindings = this.bindings.filter((bind) => bind.event !== event)\n  }\n\n  canPush() {\n    return this.socket.isConnected() && this.isJoined()\n  }\n\n  push(event: CHANNEL_EVENTS, payload: any, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if (this.canPush()) {\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  updateJoinPayload(payload: { [key: string]: unknown }): void {\n    this.joinPush.updatePayload(payload)\n  }\n\n  /**\n   * Leaves the channel\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout) {\n    this.state = CHANNEL_STATES.leaving\n    let onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`)\n      this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef())\n    }\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy()\n\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n    leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose())\n    leavePush.send()\n    if (!this.canPush()) {\n      leavePush.trigger('ok', {})\n    }\n\n    return leavePush\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   */\n  onMessage(event: string, payload: any, ref?: string) {\n    return payload\n  }\n\n  isMember(topic: string) {\n    return this.topic === topic\n  }\n\n  joinRef() {\n    return this.joinPush.ref\n  }\n\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return\n    }\n    this.socket.leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  trigger(event: string, payload?: any, ref?: string) {\n    let { close, error, leave, join } = CHANNEL_EVENTS\n    let events: string[] = [close, error, leave, join]\n    if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {\n      return\n    }\n    let handledPayload = this.onMessage(event, payload, ref)\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\n    }\n\n    this.bindings\n      .filter((bind) => {\n        // Bind all events if the user specifies a wildcard.\n        if (bind.event === '*') {\n          return event === payload?.type\n        } else {\n          return bind.event === event\n        }\n      })\n      .map((bind) => bind.callback(handledPayload, ref))\n  }\n\n  replyEventName(ref: string) {\n    return `chan_reply_${ref}`\n  }\n\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed\n  }\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored\n  }\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined\n  }\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining\n  }\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving\n  }\n}\n"]},"metadata":{},"sourceType":"module"}