{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeSubscription from './RealtimeSubscription';\nimport RealtimeChannel from './RealtimeChannel';\n\nconst noop = () => {};\n\nexport default class RealtimeClient {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint, options) {\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = w3cwebsocket;\n    this.heartbeatIntervalMs = 30000;\n    this.longpollerTimeout = 20000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    if (options === null || options === void 0 ? void 0 : options.longpollerTimeout) this.longpollerTimeout = options.longpollerTimeout;\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : tries => {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(() => __awaiter(this, void 0, void 0, function* () {\n      yield this.disconnect();\n      this.connect();\n    }), this.reconnectAfterMs);\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n\n\n  connect() {\n    if (this.conn) {\n      return;\n    }\n\n    this.conn = new this.transport(this.endPointURL(), [], null, this.headers);\n\n    if (this.conn) {\n      // this.conn.timeout = this.longpollerTimeout // TYPE ERROR\n      this.conn.binaryType = 'arraybuffer';\n\n      this.conn.onopen = () => this._onConnOpen();\n\n      this.conn.onerror = error => this._onConnError(error);\n\n      this.conn.onmessage = event => this.onConnMessage(event);\n\n      this.conn.onclose = event => this._onConnClose(event);\n    }\n  }\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n\n\n  disconnect(code, reason) {\n    return new Promise((resolve, _reject) => {\n      try {\n        if (this.conn) {\n          this.conn.onclose = function () {}; // noop\n\n\n          if (code) {\n            this.conn.close(code, reason || '');\n          } else {\n            this.conn.close();\n          }\n\n          this.conn = null; // remove open handles\n\n          this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n          this.reconnectTimer.reset();\n        }\n\n        resolve({\n          error: null,\n          data: true\n        });\n      } catch (error) {\n        resolve({\n          error: error,\n          data: false\n        });\n      }\n    });\n  }\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overriden.\n   */\n\n\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  /**\n   * Registers a callback for connection state change event.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen(() => console.log(\"Socket opened.\"))\n   */\n\n\n  onOpen(callback) {\n    this.stateChangeCallbacks.open.push(callback);\n  }\n  /**\n   * Registers a callback for connection state change events.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen(() => console.log(\"Socket closed.\"))\n   */\n\n\n  onClose(callback) {\n    this.stateChangeCallbacks.close.push(callback);\n  }\n  /**\n   * Registers a callback for connection state change events.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen((error) => console.log(\"An error occurred\"))\n   */\n\n\n  onError(callback) {\n    this.stateChangeCallbacks.error.push(callback);\n  }\n  /**\n   * Calls a function any time a message is received.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onMessage((message) => console.log(message))\n   */\n\n\n  onMessage(callback) {\n    this.stateChangeCallbacks.message.push(callback);\n  }\n  /**\n   * Returns the current state of the socket.\n   */\n\n\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting;\n\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open;\n\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing;\n\n      default:\n        return CONNECTION_STATE.Closed;\n    }\n  }\n  /**\n   * Retuns `true` is the connection is open.\n   */\n\n\n  isConnected() {\n    return this.connectionState() === CONNECTION_STATE.Open;\n  }\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   */\n\n\n  remove(channel) {\n    this.channels = this.channels.filter(c => c.joinRef() !== channel.joinRef());\n  }\n\n  channel(topic) {\n    let chanParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _a;\n\n    const {\n      selfBroadcast\n    } = chanParams,\n          params = __rest(chanParams, [\"selfBroadcast\"]);\n\n    if (selfBroadcast) {\n      params.self_broadcast = selfBroadcast;\n    }\n\n    const chan = ((_a = this.params) === null || _a === void 0 ? void 0 : _a.vsndate) ? new RealtimeChannel(topic, params, this) : new RealtimeSubscription(topic, params, this);\n\n    if (chan instanceof RealtimeChannel) {\n      chan.presence.onJoin((key, currentPresences, newPresences) => {\n        chan.trigger('presence', {\n          event: 'JOIN',\n          key,\n          currentPresences,\n          newPresences\n        });\n      });\n      chan.presence.onLeave((key, currentPresences, leftPresences) => {\n        chan.trigger('presence', {\n          event: 'LEAVE',\n          key,\n          currentPresences,\n          leftPresences\n        });\n      });\n      chan.presence.onSync(() => {\n        chan.trigger('presence', {\n          event: 'SYNC'\n        });\n      });\n    }\n\n    this.channels.push(chan);\n    return chan;\n  }\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n\n\n  push(data) {\n    const {\n      topic,\n      event,\n      payload,\n      ref\n    } = data;\n\n    let callback = () => {\n      this.encode(data, result => {\n        var _a;\n\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n      });\n    };\n\n    this.log('push', `${topic} ${event} (${ref})`, payload);\n\n    if (this.isConnected()) {\n      callback();\n    } else {\n      this.sendBuffer.push(callback);\n    }\n  }\n\n  onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, msg => {\n      let {\n        topic,\n        event,\n        payload,\n        ref\n      } = msg;\n\n      if (ref && ref === this.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n        this.pendingHeartbeatRef = null;\n      }\n\n      this.log('receive', `${payload.status || ''} ${topic} ${event} ${ref && '(' + ref + ')' || ''}`, payload);\n      this.channels.filter(channel => channel.isMember(topic)).forEach(channel => channel.trigger(event, payload, ref));\n      this.stateChangeCallbacks.message.forEach(callback => callback(msg));\n    });\n  }\n  /**\n   * Returns the URL of the websocket.\n   */\n\n\n  endPointURL() {\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n      vsn: VSN\n    }));\n  }\n  /**\n   * Return the next message ref, accounting for overflows\n   */\n\n\n  makeRef() {\n    let newRef = this.ref + 1;\n\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n\n    return this.ref.toString();\n  }\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n\n\n  setAuth(token) {\n    this.accessToken = token;\n    this.channels.forEach(channel => {\n      token && channel.updateJoinPayload({\n        user_token: token\n      });\n\n      if (channel.joinedOnce && channel.isJoined()) {\n        channel.push(CHANNEL_EVENTS.access_token, {\n          access_token: token\n        });\n      }\n    });\n  }\n  /**\n   * Unsubscribe from channels with the specified topic.\n   */\n\n\n  leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find(c => c.topic === topic && (c.isJoined() || c.isJoining()));\n\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`);\n      dupChannel.unsubscribe();\n    }\n  }\n\n  _onConnOpen() {\n    this.log('transport', `connected to ${this.endPointURL()}`);\n\n    this._flushSendBuffer();\n\n    this.reconnectTimer.reset();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n    this.stateChangeCallbacks.open.forEach(callback => callback());\n  }\n\n  _onConnClose(event) {\n    this.log('transport', 'close', event);\n\n    this._triggerChanError();\n\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.reconnectTimer.scheduleTimeout();\n    this.stateChangeCallbacks.close.forEach(callback => callback(event));\n  }\n\n  _onConnError(error) {\n    this.log('transport', error.message);\n\n    this._triggerChanError();\n\n    this.stateChangeCallbacks.error.forEach(callback => callback(error));\n  }\n\n  _triggerChanError() {\n    this.channels.forEach(channel => channel.trigger(CHANNEL_EVENTS.error));\n  }\n\n  _appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n\n    const prefix = url.match(/\\?/) ? '&' : '?';\n    const query = new URLSearchParams(params);\n    return `${url}${prefix}${query}`;\n  }\n\n  _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback());\n      this.sendBuffer = [];\n    }\n  }\n\n  _sendHeartbeat() {\n    var _a;\n\n    if (!this.isConnected()) {\n      return;\n    }\n\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n      return;\n    }\n\n    this.pendingHeartbeatRef = this.makeRef();\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef\n    });\n    this.setAuth(this.accessToken);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["w3cwebsocket","VSN","CHANNEL_EVENTS","TRANSPORTS","SOCKET_STATES","DEFAULT_TIMEOUT","WS_CLOSE_NORMAL","DEFAULT_HEADERS","CONNECTION_STATE","Timer","Serializer","RealtimeSubscription","RealtimeChannel","noop","RealtimeClient","constructor","endPoint","options","undefined","open","close","error","message","websocket","params","headers","Object","timeout","logger","transport","heartbeatIntervalMs","longpollerTimeout","reconnectAfterMs","tries","encode","payload","callback","JSON","stringify","decode","serializer","bind","reconnectTimer","__awaiter","disconnect","connect","conn","endPointURL","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","event","onConnMessage","onclose","_onConnClose","code","reason","Promise","resolve","_reject","heartbeatTimer","clearInterval","reset","data","log","kind","msg","onOpen","stateChangeCallbacks","push","onClose","onError","onMessage","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","isConnected","remove","channel","channels","filter","c","joinRef","topic","chanParams","selfBroadcast","self_broadcast","chan","_a","vsndate","presence","onJoin","key","currentPresences","newPresences","trigger","onLeave","leftPresences","onSync","ref","result","send","sendBuffer","rawMessage","pendingHeartbeatRef","type","status","isMember","forEach","_appendParams","assign","vsn","makeRef","newRef","toString","setAuth","token","accessToken","updateJoinPayload","user_token","joinedOnce","isJoined","access_token","leaveOpenTopic","dupChannel","find","isJoining","unsubscribe","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","scheduleTimeout","url","keys","length","prefix","match","query","URLSearchParams"],"sources":["/home/gabriel/Dropbox/Ufersa/Aulas/PW/2021.2/Unidade 2/aula 8 - pratica/todo/node_modules/@supabase/realtime-js/src/RealtimeClient.ts"],"sourcesContent":["import { w3cwebsocket } from 'websocket'\nimport {\n  VSN,\n  CHANNEL_EVENTS,\n  TRANSPORTS,\n  SOCKET_STATES,\n  DEFAULT_TIMEOUT,\n  WS_CLOSE_NORMAL,\n  DEFAULT_HEADERS,\n  CONNECTION_STATE,\n} from './lib/constants'\nimport Timer from './lib/timer'\nimport Serializer from './lib/serializer'\nimport RealtimeSubscription from './RealtimeSubscription'\nimport RealtimeChannel from './RealtimeChannel'\n\nexport type Options = {\n  transport?: WebSocket\n  timeout?: number\n  heartbeatIntervalMs?: number\n  longpollerTimeout?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: string }\n}\ntype Message = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n}\n\ntype ChannelParams = {\n  selfBroadcast?: boolean\n  [key: string]: any\n}\n\nconst noop = () => {}\n\nexport default class RealtimeClient {\n  accessToken: string | null = null\n  channels: (RealtimeSubscription | RealtimeChannel)[] = []\n  endPoint: string = ''\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: any = w3cwebsocket\n  heartbeatIntervalMs: number = 30000\n  longpollerTimeout: number = 20000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocket | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint: string, options?: Options) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n\n    if (options?.params) this.params = options.params\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.transport) this.transport = options.transport\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n    if (options?.longpollerTimeout)\n      this.longpollerTimeout = options.longpollerTimeout\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      await this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    if (this.conn) {\n      return\n    }\n\n    this.conn = new this.transport(this.endPointURL(), [], null, this.headers)\n\n    if (this.conn) {\n      // this.conn.timeout = this.longpollerTimeout // TYPE ERROR\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error) => this._onConnError(error as ErrorEvent)\n      this.conn.onmessage = (event) => this.onConnMessage(event)\n      this.conn.onclose = (event) => this._onConnClose(event)\n    }\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(\n    code?: number,\n    reason?: string\n  ): Promise<{ error: Error | null; data: boolean }> {\n    return new Promise((resolve, _reject) => {\n      try {\n        if (this.conn) {\n          this.conn.onclose = function () {} // noop\n          if (code) {\n            this.conn.close(code, reason || '')\n          } else {\n            this.conn.close()\n          }\n          this.conn = null\n          // remove open handles\n          this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n          this.reconnectTimer.reset()\n        }\n        resolve({ error: null, data: true })\n      } catch (error) {\n        resolve({ error: error as Error, data: false })\n      }\n    })\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overriden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Registers a callback for connection state change event.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen(() => console.log(\"Socket opened.\"))\n   */\n  onOpen(callback: Function) {\n    this.stateChangeCallbacks.open.push(callback)\n  }\n\n  /**\n   * Registers a callback for connection state change events.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen(() => console.log(\"Socket closed.\"))\n   */\n  onClose(callback: Function) {\n    this.stateChangeCallbacks.close.push(callback)\n  }\n\n  /**\n   * Registers a callback for connection state change events.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen((error) => console.log(\"An error occurred\"))\n   */\n  onError(callback: Function) {\n    this.stateChangeCallbacks.error.push(callback)\n  }\n\n  /**\n   * Calls a function any time a message is received.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onMessage((message) => console.log(message))\n   */\n  onMessage(callback: Function) {\n    this.stateChangeCallbacks.message.push(callback)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Retuns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   */\n  remove(channel: RealtimeSubscription | RealtimeChannel) {\n    this.channels = this.channels.filter(\n      (c: RealtimeSubscription | RealtimeChannel) =>\n        c.joinRef() !== channel.joinRef()\n    )\n  }\n\n  channel(\n    topic: string,\n    chanParams: ChannelParams = {}\n  ): RealtimeChannel | RealtimeSubscription {\n    const { selfBroadcast, ...params } = chanParams\n\n    if (selfBroadcast) {\n      params.self_broadcast = selfBroadcast\n    }\n\n    const chan = this.params?.vsndate\n      ? new RealtimeChannel(topic, params, this)\n      : new RealtimeSubscription(topic, params, this)\n\n    if (chan instanceof RealtimeChannel) {\n      chan.presence.onJoin((key, currentPresences, newPresences) => {\n        chan.trigger('presence', {\n          event: 'JOIN',\n          key,\n          currentPresences,\n          newPresences,\n        })\n      })\n\n      chan.presence.onLeave((key, currentPresences, leftPresences) => {\n        chan.trigger('presence', {\n          event: 'LEAVE',\n          key,\n          currentPresences,\n          leftPresences,\n        })\n      })\n\n      chan.presence.onSync(() => {\n        chan.trigger('presence', { event: 'SYNC' })\n      })\n    }\n\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: Message): void {\n    const { topic, event, payload, ref } = data\n    let callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      callback()\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: Message) => {\n      let { topic, event, payload, ref } = msg\n\n      if (\n        (ref && ref === this.pendingHeartbeatRef) ||\n        event === payload?.type\n      ) {\n        this.pendingHeartbeatRef = null\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n      this.channels\n        .filter((channel: RealtimeSubscription | RealtimeChannel) =>\n          channel.isMember(topic)\n        )\n        .forEach((channel: RealtimeSubscription | RealtimeChannel) =>\n          channel.trigger(event, payload, ref)\n        )\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   */\n  endPointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   */\n  makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token: string | null) {\n    this.accessToken = token\n\n    this.channels.forEach((channel) => {\n      token && channel.updateJoinPayload({ user_token: token })\n\n      if (channel.joinedOnce && channel.isJoined()) {\n        channel.push(CHANNEL_EVENTS.access_token, { access_token: token })\n      }\n    })\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   */\n  leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c.isJoined() || c.isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  private _onConnOpen() {\n    this.log('transport', `connected to ${this.endPointURL()}`)\n    this._flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(\n      () => this._sendHeartbeat(),\n      this.heartbeatIntervalMs\n    )\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\n  }\n\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  private _onConnError(error: ErrorEvent) {\n    this.log('transport', error.message)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeSubscription | RealtimeChannel) =>\n      channel.trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n\n    return `${url}${prefix}${query}`\n  }\n\n  private _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n\n  private _sendHeartbeat() {\n    if (!this.isConnected()) {\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this.makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.setAuth(this.accessToken)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}