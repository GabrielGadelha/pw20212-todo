{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants';\nimport { stripTrailingSlash, isBrowser } from './lib/helpers';\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient';\nimport { SupabaseQueryBuilder } from './lib/SupabaseQueryBuilder';\nimport { SupabaseStorageClient } from '@supabase/storage-js';\nimport { FunctionsClient } from '@supabase/functions-js';\nimport { PostgrestClient } from '@supabase/postgrest-js';\nimport { RealtimeClient } from '@supabase/realtime-js';\nconst DEFAULT_OPTIONS = {\n  schema: 'public',\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS\n};\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\n\nexport default class SupabaseClient {\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.headers Any additional headers to send with each network request.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(supabaseUrl, supabaseKey, options) {\n    this.supabaseUrl = supabaseUrl;\n    this.supabaseKey = supabaseKey;\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.');\n    if (!supabaseKey) throw new Error('supabaseKey is required.');\n\n    const _supabaseUrl = stripTrailingSlash(supabaseUrl);\n\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.restUrl = `${_supabaseUrl}/rest/v1`;\n    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace('http', 'ws');\n    this.authUrl = `${_supabaseUrl}/auth/v1`;\n    this.storageUrl = `${_supabaseUrl}/storage/v1`;\n\n    const isPlatform = _supabaseUrl.match(/(supabase\\.co)|(supabase\\.in)/);\n\n    if (isPlatform) {\n      const urlParts = _supabaseUrl.split('.');\n\n      this.functionsUrl = `${urlParts[0]}.functions.${urlParts[1]}.${urlParts[2]}`;\n    } else {\n      this.functionsUrl = `${_supabaseUrl}/functions/v1`;\n    }\n\n    this.schema = settings.schema;\n    this.multiTab = settings.multiTab;\n    this.fetch = settings.fetch;\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), options === null || options === void 0 ? void 0 : options.headers);\n    this.shouldThrowOnError = settings.shouldThrowOnError || false;\n    this.auth = this._initSupabaseAuthClient(settings);\n    this.realtime = this._initRealtimeClient(Object.assign({\n      headers: this.headers\n    }, settings.realtime));\n\n    this._listenForAuthEvents();\n\n    this._listenForMultiTabEvents(); // In the future we might allow the user to pass in a logger to receive these events.\n    // this.realtime.onOpen(() => console.log('OPEN'))\n    // this.realtime.onClose(() => console.log('CLOSED'))\n    // this.realtime.onError((e: Error) => console.log('Socket error', e))\n\n  }\n  /**\n   * Supabase Functions allows you to deploy and invoke edge functions.\n   */\n\n\n  get functions() {\n    return new FunctionsClient(this.functionsUrl, {\n      headers: this._getAuthHeaders(),\n      customFetch: this.fetch\n    });\n  }\n  /**\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n   */\n\n\n  get storage() {\n    return new SupabaseStorageClient(this.storageUrl, this._getAuthHeaders(), this.fetch);\n  }\n  /**\n   * Perform a table operation.\n   *\n   * @param table The table name to operate on.\n   */\n\n\n  from(table) {\n    const url = `${this.restUrl}/${table}`;\n    return new SupabaseQueryBuilder(url, {\n      headers: this._getAuthHeaders(),\n      schema: this.schema,\n      realtime: this.realtime,\n      table,\n      fetch: this.fetch,\n      shouldThrowOnError: this.shouldThrowOnError\n    });\n  }\n  /**\n   * Perform a function call.\n   *\n   * @param fn  The function name to call.\n   * @param params  The parameters to pass to the function call.\n   * @param head   When set to true, no data will be returned.\n   * @param count  Count algorithm to use to count rows in a table.\n   *\n   */\n\n\n  rpc(fn, params) {\n    let {\n      head = false,\n      count = null\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    const rest = this._initPostgRESTClient();\n\n    return rest.rpc(fn, params, {\n      head,\n      count\n    });\n  }\n  /**\n   * Creates a channel with Broadcast and Presence.\n   * Activated when vsndate query param is present in the WebSocket URL.\n   */\n\n\n  channel(name, opts) {\n    var _a, _b;\n\n    const userToken = (_b = (_a = this.auth.session()) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;\n\n    if (!this.realtime.isConnected()) {\n      this.realtime.connect();\n    }\n\n    return this.realtime.channel(name, Object.assign(Object.assign({}, opts), {\n      user_token: userToken\n    }));\n  }\n  /**\n   * Closes and removes all subscriptions and returns a list of removed\n   * subscriptions and their errors.\n   */\n\n\n  removeAllSubscriptions() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const allSubs = this.getSubscriptions().slice();\n      const allSubPromises = allSubs.map(sub => this.removeSubscription(sub));\n      const allRemovedSubs = yield Promise.all(allSubPromises);\n      return allRemovedSubs.map((_ref, i) => {\n        let {\n          error\n        } = _ref;\n        return {\n          data: {\n            subscription: allSubs[i]\n          },\n          error\n        };\n      });\n    });\n  }\n  /**\n   * Closes and removes a channel and returns the number of open channels.\n   *\n   * @param channel The channel you want to close and remove.\n   */\n\n\n  removeChannel(channel) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        error\n      } = yield this._closeSubscription(channel);\n      const allChans = this.getSubscriptions();\n      const openChanCount = allChans.filter(chan => chan.isJoined()).length;\n      if (allChans.length === 0) yield this.realtime.disconnect();\n      return {\n        data: {\n          openChannels: openChanCount\n        },\n        error\n      };\n    });\n  }\n  /**\n   * Closes and removes a subscription and returns the number of open subscriptions.\n   *\n   * @param subscription The subscription you want to close and remove.\n   */\n\n\n  removeSubscription(subscription) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        error\n      } = yield this._closeSubscription(subscription);\n      const allSubs = this.getSubscriptions();\n      const openSubCount = allSubs.filter(chan => chan.isJoined()).length;\n      if (allSubs.length === 0) yield this.realtime.disconnect();\n      return {\n        data: {\n          openSubscriptions: openSubCount\n        },\n        error\n      };\n    });\n  }\n\n  _closeSubscription(subscription) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let error = null;\n\n      if (!subscription.isClosed()) {\n        const {\n          error: unsubError\n        } = yield this._unsubscribeSubscription(subscription);\n        error = unsubError;\n      }\n\n      this.realtime.remove(subscription);\n      return {\n        error\n      };\n    });\n  }\n\n  _unsubscribeSubscription(subscription) {\n    return new Promise(resolve => {\n      subscription.unsubscribe().receive('ok', () => resolve({\n        error: null\n      })).receive('error', error => resolve({\n        error\n      })).receive('timeout', () => resolve({\n        error: new Error('timed out')\n      }));\n    });\n  }\n  /**\n   * Returns an array of all your subscriptions.\n   */\n\n\n  getSubscriptions() {\n    return this.realtime.channels;\n  }\n\n  _initSupabaseAuthClient(_ref2) {\n    let {\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      localStorage,\n      headers,\n      fetch,\n      cookieOptions,\n      multiTab\n    } = _ref2;\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`\n    };\n    return new SupabaseAuthClient({\n      url: this.authUrl,\n      headers: Object.assign(Object.assign({}, headers), authHeaders),\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      localStorage,\n      fetch,\n      cookieOptions,\n      multiTab\n    });\n  }\n\n  _initRealtimeClient(options) {\n    return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), {\n      params: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.params), {\n        apikey: this.supabaseKey\n      })\n    }));\n  }\n\n  _initPostgRESTClient() {\n    return new PostgrestClient(this.restUrl, {\n      headers: this._getAuthHeaders(),\n      schema: this.schema,\n      fetch: this.fetch,\n      throwOnError: this.shouldThrowOnError\n    });\n  }\n\n  _getAuthHeaders() {\n    var _a, _b;\n\n    const headers = Object.assign({}, this.headers);\n    const authBearer = (_b = (_a = this.auth.session()) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;\n    headers['apikey'] = this.supabaseKey;\n    headers['Authorization'] = headers['Authorization'] || `Bearer ${authBearer}`;\n    return headers;\n  }\n\n  _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      return null;\n    }\n\n    try {\n      return window === null || window === void 0 ? void 0 : window.addEventListener('storage', e => {\n        var _a, _b, _c;\n\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue));\n          const accessToken = (_b = (_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n          const previousAccessToken = (_c = this.auth.session()) === null || _c === void 0 ? void 0 : _c.access_token;\n\n          if (!accessToken) {\n            this._handleTokenChanged('SIGNED_OUT', accessToken, 'STORAGE');\n          } else if (!previousAccessToken && accessToken) {\n            this._handleTokenChanged('SIGNED_IN', accessToken, 'STORAGE');\n          } else if (previousAccessToken !== accessToken) {\n            this._handleTokenChanged('TOKEN_REFRESHED', accessToken, 'STORAGE');\n          }\n        }\n      });\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error);\n      return null;\n    }\n  }\n\n  _listenForAuthEvents() {\n    let {\n      data\n    } = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, session === null || session === void 0 ? void 0 : session.access_token, 'CLIENT');\n    });\n    return data;\n  }\n\n  _handleTokenChanged(event, token, source) {\n    if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') && this.changedAccessToken !== token) {\n      // Token has changed\n      this.realtime.setAuth(token); // Ideally we should call this.auth.recoverSession() - need to make public\n      // to trigger a \"SIGNED_IN\" event on this client.\n\n      if (source == 'STORAGE') this.auth.setAuth(token);\n      this.changedAccessToken = token;\n    } else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\n      // Token is removed\n      this.realtime.setAuth(this.supabaseKey);\n      if (source == 'STORAGE') this.auth.signOut();\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["DEFAULT_HEADERS","STORAGE_KEY","stripTrailingSlash","isBrowser","SupabaseAuthClient","SupabaseQueryBuilder","SupabaseStorageClient","FunctionsClient","PostgrestClient","RealtimeClient","DEFAULT_OPTIONS","schema","autoRefreshToken","persistSession","detectSessionInUrl","multiTab","headers","SupabaseClient","constructor","supabaseUrl","supabaseKey","options","Error","_supabaseUrl","settings","restUrl","realtimeUrl","replace","authUrl","storageUrl","isPlatform","match","urlParts","split","functionsUrl","fetch","Object","shouldThrowOnError","auth","_initSupabaseAuthClient","realtime","_initRealtimeClient","_listenForAuthEvents","_listenForMultiTabEvents","functions","_getAuthHeaders","customFetch","storage","from","table","url","rpc","fn","params","head","count","rest","_initPostgRESTClient","channel","name","opts","userToken","session","_a","access_token","_b","isConnected","connect","user_token","removeAllSubscriptions","allSubs","getSubscriptions","slice","allSubPromises","map","sub","removeSubscription","allRemovedSubs","Promise","all","i","error","data","subscription","removeChannel","_closeSubscription","allChans","openChanCount","filter","chan","isJoined","length","disconnect","openChannels","openSubCount","openSubscriptions","isClosed","unsubError","_unsubscribeSubscription","remove","resolve","unsubscribe","receive","channels","localStorage","cookieOptions","authHeaders","Authorization","apikey","throwOnError","authBearer","window","addEventListener","e","key","newSession","JSON","parse","String","newValue","accessToken","currentSession","undefined","previousAccessToken","_c","_handleTokenChanged","console","onAuthStateChange","event","token","source","changedAccessToken","setAuth","signOut"],"sources":["/home/gabriel/Dropbox/Ufersa/Aulas/PW/2021.2/Unidade 2/aula 8 - pratica/todo/node_modules/@supabase/supabase-js/src/SupabaseClient.ts"],"sourcesContent":["import { DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants'\nimport { stripTrailingSlash, isBrowser } from './lib/helpers'\nimport { Fetch, GenericObject, SupabaseClientOptions } from './lib/types'\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient'\nimport { SupabaseQueryBuilder } from './lib/SupabaseQueryBuilder'\nimport { SupabaseStorageClient } from '@supabase/storage-js'\nimport { FunctionsClient } from '@supabase/functions-js'\nimport { PostgrestClient } from '@supabase/postgrest-js'\nimport { AuthChangeEvent } from '@supabase/gotrue-js'\nimport {\n  RealtimeClient,\n  RealtimeSubscription,\n  RealtimeClientOptions,\n  RealtimeChannel,\n} from '@supabase/realtime-js'\n\nconst DEFAULT_OPTIONS = {\n  schema: 'public',\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS,\n}\n\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nexport default class SupabaseClient {\n  /**\n   * Supabase Auth allows you to create and manage user sessions for access to data that is secured by access policies.\n   */\n  auth: SupabaseAuthClient\n\n  protected schema: string\n  protected restUrl: string\n  protected realtimeUrl: string\n  protected authUrl: string\n  protected storageUrl: string\n  protected functionsUrl: string\n  protected realtime: RealtimeClient\n  protected multiTab: boolean\n  protected fetch?: Fetch\n  protected changedAccessToken: string | undefined\n  protected shouldThrowOnError: boolean\n\n  protected headers: {\n    [key: string]: string\n  }\n\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.headers Any additional headers to send with each network request.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(\n    protected supabaseUrl: string,\n    protected supabaseKey: string,\n    options?: SupabaseClientOptions\n  ) {\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.')\n    if (!supabaseKey) throw new Error('supabaseKey is required.')\n\n    const _supabaseUrl = stripTrailingSlash(supabaseUrl)\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n\n    this.restUrl = `${_supabaseUrl}/rest/v1`\n    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace('http', 'ws')\n    this.authUrl = `${_supabaseUrl}/auth/v1`\n    this.storageUrl = `${_supabaseUrl}/storage/v1`\n\n    const isPlatform = _supabaseUrl.match(/(supabase\\.co)|(supabase\\.in)/)\n    if (isPlatform) {\n      const urlParts = _supabaseUrl.split('.')\n      this.functionsUrl = `${urlParts[0]}.functions.${urlParts[1]}.${urlParts[2]}`\n    } else {\n      this.functionsUrl = `${_supabaseUrl}/functions/v1`\n    }\n\n    this.schema = settings.schema\n    this.multiTab = settings.multiTab\n    this.fetch = settings.fetch\n    this.headers = { ...DEFAULT_HEADERS, ...options?.headers }\n    this.shouldThrowOnError = settings.shouldThrowOnError || false\n\n    this.auth = this._initSupabaseAuthClient(settings)\n    this.realtime = this._initRealtimeClient({ headers: this.headers, ...settings.realtime })\n\n    this._listenForAuthEvents()\n    this._listenForMultiTabEvents()\n\n    // In the future we might allow the user to pass in a logger to receive these events.\n    // this.realtime.onOpen(() => console.log('OPEN'))\n    // this.realtime.onClose(() => console.log('CLOSED'))\n    // this.realtime.onError((e: Error) => console.log('Socket error', e))\n  }\n\n  /**\n   * Supabase Functions allows you to deploy and invoke edge functions.\n   */\n  get functions() {\n    return new FunctionsClient(this.functionsUrl, {\n      headers: this._getAuthHeaders(),\n      customFetch: this.fetch,\n    })\n  }\n\n  /**\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n   */\n  get storage() {\n    return new SupabaseStorageClient(this.storageUrl, this._getAuthHeaders(), this.fetch)\n  }\n\n  /**\n   * Perform a table operation.\n   *\n   * @param table The table name to operate on.\n   */\n  from<T = any>(table: string): SupabaseQueryBuilder<T> {\n    const url = `${this.restUrl}/${table}`\n    return new SupabaseQueryBuilder<T>(url, {\n      headers: this._getAuthHeaders(),\n      schema: this.schema,\n      realtime: this.realtime,\n      table,\n      fetch: this.fetch,\n      shouldThrowOnError: this.shouldThrowOnError,\n    })\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn  The function name to call.\n   * @param params  The parameters to pass to the function call.\n   * @param head   When set to true, no data will be returned.\n   * @param count  Count algorithm to use to count rows in a table.\n   *\n   */\n  rpc<T = any>(\n    fn: string,\n    params?: object,\n    {\n      head = false,\n      count = null,\n    }: { head?: boolean; count?: null | 'exact' | 'planned' | 'estimated' } = {}\n  ) {\n    const rest = this._initPostgRESTClient()\n    return rest.rpc<T>(fn, params, { head, count })\n  }\n\n  /**\n   * Creates a channel with Broadcast and Presence.\n   * Activated when vsndate query param is present in the WebSocket URL.\n   */\n  channel(name: string, opts: { selfBroadcast: boolean; [key: string]: any }): RealtimeChannel {\n    const userToken = this.auth.session()?.access_token ?? this.supabaseKey\n\n    if (!this.realtime.isConnected()) {\n      this.realtime.connect()\n    }\n\n    return this.realtime.channel(name, { ...opts, user_token: userToken }) as RealtimeChannel\n  }\n\n  /**\n   * Closes and removes all subscriptions and returns a list of removed\n   * subscriptions and their errors.\n   */\n  async removeAllSubscriptions(): Promise<\n    { data: { subscription: RealtimeSubscription }; error: Error | null }[]\n  > {\n    const allSubs: RealtimeSubscription[] = this.getSubscriptions().slice()\n    const allSubPromises = allSubs.map((sub) => this.removeSubscription(sub))\n    const allRemovedSubs = await Promise.all(allSubPromises)\n\n    return allRemovedSubs.map(({ error }, i) => {\n      return {\n        data: { subscription: allSubs[i] },\n        error,\n      }\n    })\n  }\n\n  /**\n   * Closes and removes a channel and returns the number of open channels.\n   *\n   * @param channel The channel you want to close and remove.\n   */\n  async removeChannel(\n    channel: RealtimeChannel\n  ): Promise<{ data: { openChannels: number }; error: Error | null }> {\n    const { error } = await this._closeSubscription(channel)\n    const allChans: RealtimeSubscription[] = this.getSubscriptions()\n    const openChanCount = allChans.filter((chan) => chan.isJoined()).length\n\n    if (allChans.length === 0) await this.realtime.disconnect()\n\n    return { data: { openChannels: openChanCount }, error }\n  }\n\n  /**\n   * Closes and removes a subscription and returns the number of open subscriptions.\n   *\n   * @param subscription The subscription you want to close and remove.\n   */\n  async removeSubscription(\n    subscription: RealtimeSubscription\n  ): Promise<{ data: { openSubscriptions: number }; error: Error | null }> {\n    const { error } = await this._closeSubscription(subscription)\n    const allSubs: RealtimeSubscription[] = this.getSubscriptions()\n    const openSubCount = allSubs.filter((chan) => chan.isJoined()).length\n\n    if (allSubs.length === 0) await this.realtime.disconnect()\n\n    return { data: { openSubscriptions: openSubCount }, error }\n  }\n\n  private async _closeSubscription(\n    subscription: RealtimeSubscription | RealtimeChannel\n  ): Promise<{ error: Error | null }> {\n    let error = null\n\n    if (!subscription.isClosed()) {\n      const { error: unsubError } = await this._unsubscribeSubscription(subscription)\n      error = unsubError\n    }\n\n    this.realtime.remove(subscription)\n\n    return { error }\n  }\n\n  private _unsubscribeSubscription(\n    subscription: RealtimeSubscription | RealtimeChannel\n  ): Promise<{ error: Error | null }> {\n    return new Promise((resolve) => {\n      subscription\n        .unsubscribe()\n        .receive('ok', () => resolve({ error: null }))\n        .receive('error', (error: Error) => resolve({ error }))\n        .receive('timeout', () => resolve({ error: new Error('timed out') }))\n    })\n  }\n\n  /**\n   * Returns an array of all your subscriptions.\n   */\n  getSubscriptions(): RealtimeSubscription[] {\n    return this.realtime.channels as RealtimeSubscription[]\n  }\n\n  private _initSupabaseAuthClient({\n    autoRefreshToken,\n    persistSession,\n    detectSessionInUrl,\n    localStorage,\n    headers,\n    fetch,\n    cookieOptions,\n    multiTab,\n  }: SupabaseClientOptions) {\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`,\n    }\n    return new SupabaseAuthClient({\n      url: this.authUrl,\n      headers: { ...headers, ...authHeaders },\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      localStorage,\n      fetch,\n      cookieOptions,\n      multiTab,\n    })\n  }\n\n  private _initRealtimeClient(options?: RealtimeClientOptions) {\n    return new RealtimeClient(this.realtimeUrl, {\n      ...options,\n      params: { ...options?.params, apikey: this.supabaseKey },\n    })\n  }\n\n  private _initPostgRESTClient() {\n    return new PostgrestClient(this.restUrl, {\n      headers: this._getAuthHeaders(),\n      schema: this.schema,\n      fetch: this.fetch,\n      throwOnError: this.shouldThrowOnError,\n    })\n  }\n\n  private _getAuthHeaders(): GenericObject {\n    const headers: GenericObject = { ...this.headers }\n    const authBearer = this.auth.session()?.access_token ?? this.supabaseKey\n    headers['apikey'] = this.supabaseKey\n    headers['Authorization'] = headers['Authorization'] || `Bearer ${authBearer}`\n    return headers\n  }\n\n  private _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !window?.addEventListener) {\n      return null\n    }\n\n    try {\n      return window?.addEventListener('storage', (e: StorageEvent) => {\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue))\n          const accessToken: string | undefined =\n            newSession?.currentSession?.access_token ?? undefined\n          const previousAccessToken = this.auth.session()?.access_token\n          if (!accessToken) {\n            this._handleTokenChanged('SIGNED_OUT', accessToken, 'STORAGE')\n          } else if (!previousAccessToken && accessToken) {\n            this._handleTokenChanged('SIGNED_IN', accessToken, 'STORAGE')\n          } else if (previousAccessToken !== accessToken) {\n            this._handleTokenChanged('TOKEN_REFRESHED', accessToken, 'STORAGE')\n          }\n        }\n      })\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error)\n      return null\n    }\n  }\n\n  private _listenForAuthEvents() {\n    let { data } = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, session?.access_token, 'CLIENT')\n    })\n    return data\n  }\n\n  private _handleTokenChanged(\n    event: AuthChangeEvent,\n    token: string | undefined,\n    source: 'CLIENT' | 'STORAGE'\n  ) {\n    if (\n      (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n      this.changedAccessToken !== token\n    ) {\n      // Token has changed\n      this.realtime.setAuth(token!)\n      // Ideally we should call this.auth.recoverSession() - need to make public\n      // to trigger a \"SIGNED_IN\" event on this client.\n      if (source == 'STORAGE') this.auth.setAuth(token!)\n\n      this.changedAccessToken = token\n    } else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\n      // Token is removed\n      this.realtime.setAuth(this.supabaseKey)\n      if (source == 'STORAGE') this.auth.signOut()\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}